// Code generated by girgen. DO NOT EDIT.

package adw

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gtk/v4"
)

// #include <stdlib.h>
// #include <adwaita.h>
// #include <glib-object.h>
import "C"

// GType values.
var (
	GTypeWrapBox = coreglib.Type(C.adw_wrap_box_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeWrapBox, F: marshalWrapBox},
	})
}

// WrapBoxOverrides contains methods that are overridable.
type WrapBoxOverrides struct {
}

func defaultWrapBoxOverrides(v *WrapBox) WrapBoxOverrides {
	return WrapBoxOverrides{}
}

// WrapBox: box-like widget that can wrap into multiple lines.
//
// <picture> <source srcset="wrap-box-dark.png" media="(prefers-color-scheme:
// dark)"> <img src="wrap-box.png" alt="wrap-box"> </picture>
//
// AdwWrapBox is similar to gtk.Box, but can wrap lines when the widgets cannot
// fit otherwise. Unlike gtk.FlowBox, the children aren't arranged into a grid
// and behave more like words in a wrapping label.
//
// Like GtkBox, AdwWrapBox is orientable and has spacing:
//
// - wrapbox:child-spacing between children in the same line;
//
// - wrapbox:line-spacing between lines.
//
// ::: note Unlike GtkBox, AdwWrapBox cannot follow the CSS border-spacing
// property.
//
// Use the wrapbox:natural-line-length property to determine the layout's
// natural size, e.g. when using it in a gtk.Popover.
//
// Normally, a horizontal AdwWrapBox wraps left to right and top to bottom for
// left-to-right languages. Both of these directions can be reversed, using the
// wrapbox:pack-direction and wrapbox:wrap-reverse properties. Additionally,
// the alignment of each line can be controlled with the wrapbox:align property.
//
// Lines can be justified using the wrapbox:justify property, filling the entire
// line by either increasing child size or spacing depending on the value.
// Set wrapbox:justify-last-line to justify the last line as well.
//
// By default, AdwWrapBox wraps as soon as the previous line cannot fit
// any more children without shrinking them past their natural size.
// Set wrapbox:wrap-policy to adw.WrapPolicy.MINIMUM to only wrap once all the
// children in the previous line have been shrunk to their minimum size.
//
// To make each line take the same amount of space, set wrapbox:line-homogeneous
// to TRUE.
//
// Spacing and natural line length can scale with the text scale factor,
// use the wrapbox:child-spacing-unit, wrapbox:line-spacing-unit and/or
// wrapbox:natural-line-length-unit properties to enable that behavior.
//
// See wraplayout.
//
// # CSS nodes
//
// AdwWrapBox uses a single CSS node with name wrap-box.
//
// # Accessibility
//
// AdwWrapBox uses the GTK_ACCESSIBLE_ROLE_GROUP role.
type WrapBox struct {
	_ [0]func() // equal guard
	gtk.Widget

	*coreglib.Object
	gtk.Orientable
}

var (
	_ gtk.Widgetter     = (*WrapBox)(nil)
	_ coreglib.Objector = (*WrapBox)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*WrapBox, *WrapBoxClass, WrapBoxOverrides](
		GTypeWrapBox,
		initWrapBoxClass,
		wrapWrapBox,
		defaultWrapBoxOverrides,
	)
}

func initWrapBoxClass(gclass unsafe.Pointer, overrides WrapBoxOverrides, classInitFunc func(*WrapBoxClass)) {
	if classInitFunc != nil {
		class := (*WrapBoxClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapWrapBox(obj *coreglib.Object) *WrapBox {
	return &WrapBox{
		Widget: gtk.Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: gtk.Accessible{
				Object: obj,
			},
			Buildable: gtk.Buildable{
				Object: obj,
			},
			ConstraintTarget: gtk.ConstraintTarget{
				Object: obj,
			},
		},
		Object: obj,
		Orientable: gtk.Orientable{
			Object: obj,
		},
	}
}

func marshalWrapBox(p uintptr) (interface{}, error) {
	return wrapWrapBox(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewWrapBox creates a new AdwWrapBox.
//
// The function returns the following values:
//
//   - wrapBox: newly created AdwWrapBox.
func NewWrapBox() *WrapBox {
	var _cret *C.GtkWidget // in

	_cret = C.adw_wrap_box_new()

	var _wrapBox *WrapBox // out

	_wrapBox = wrapWrapBox(coreglib.Take(unsafe.Pointer(_cret)))

	return _wrapBox
}

// Append adds child as the last child to self.
//
// The function takes the following parameters:
//
//   - child: widget to append.
func (self *WrapBox) Append(child gtk.Widgetter) {
	var _arg0 *C.AdwWrapBox // out
	var _arg1 *C.GtkWidget  // out

	_arg0 = (*C.AdwWrapBox)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	C.adw_wrap_box_append(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(child)
}

// Align gets the alignment of the children within each line.
//
// The function returns the following values:
//
//   - gfloat: child alignment.
func (self *WrapBox) Align() float32 {
	var _arg0 *C.AdwWrapBox // out
	var _cret C.float       // in

	_arg0 = (*C.AdwWrapBox)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_wrap_box_get_align(_arg0)
	runtime.KeepAlive(self)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// ChildSpacing gets spacing between widgets on the same line.
//
// The function returns the following values:
//
//   - gint: spacing between widgets on the same line.
func (self *WrapBox) ChildSpacing() int {
	var _arg0 *C.AdwWrapBox // out
	var _cret C.int         // in

	_arg0 = (*C.AdwWrapBox)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_wrap_box_get_child_spacing(_arg0)
	runtime.KeepAlive(self)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// ChildSpacingUnit gets the length unit for child spacing.
//
// The function returns the following values:
//
//   - lengthUnit: length unit.
func (self *WrapBox) ChildSpacingUnit() LengthUnit {
	var _arg0 *C.AdwWrapBox   // out
	var _cret C.AdwLengthUnit // in

	_arg0 = (*C.AdwWrapBox)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_wrap_box_get_child_spacing_unit(_arg0)
	runtime.KeepAlive(self)

	var _lengthUnit LengthUnit // out

	_lengthUnit = LengthUnit(_cret)

	return _lengthUnit
}

// Justify gets whether and how each complete line is stretched to fill the
// entire widget.
//
// The function returns the following values:
//
//   - justifyMode: justify mode.
func (self *WrapBox) Justify() JustifyMode {
	var _arg0 *C.AdwWrapBox    // out
	var _cret C.AdwJustifyMode // in

	_arg0 = (*C.AdwWrapBox)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_wrap_box_get_justify(_arg0)
	runtime.KeepAlive(self)

	var _justifyMode JustifyMode // out

	_justifyMode = JustifyMode(_cret)

	return _justifyMode
}

// JustifyLastLine gets whether the last line should be stretched to fill the
// entire widget.
//
// The function returns the following values:
//
//   - ok: whether the last line is justified.
func (self *WrapBox) JustifyLastLine() bool {
	var _arg0 *C.AdwWrapBox // out
	var _cret C.gboolean    // in

	_arg0 = (*C.AdwWrapBox)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_wrap_box_get_justify_last_line(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// LineHomogeneous gets whether all lines should take the same amount of space.
//
// The function returns the following values:
//
//   - ok: whether lines should be homogeneous.
func (self *WrapBox) LineHomogeneous() bool {
	var _arg0 *C.AdwWrapBox // out
	var _cret C.gboolean    // in

	_arg0 = (*C.AdwWrapBox)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_wrap_box_get_line_homogeneous(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// LineSpacing gets the spacing between lines.
//
// See wrapbox:line-spacing-unit.
//
// The function returns the following values:
//
//   - gint: line spacing.
func (self *WrapBox) LineSpacing() int {
	var _arg0 *C.AdwWrapBox // out
	var _cret C.int         // in

	_arg0 = (*C.AdwWrapBox)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_wrap_box_get_line_spacing(_arg0)
	runtime.KeepAlive(self)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// LineSpacingUnit gets the length unit for line spacing.
//
// The function returns the following values:
//
//   - lengthUnit: length unit.
func (self *WrapBox) LineSpacingUnit() LengthUnit {
	var _arg0 *C.AdwWrapBox   // out
	var _cret C.AdwLengthUnit // in

	_arg0 = (*C.AdwWrapBox)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_wrap_box_get_line_spacing_unit(_arg0)
	runtime.KeepAlive(self)

	var _lengthUnit LengthUnit // out

	_lengthUnit = LengthUnit(_cret)

	return _lengthUnit
}

// NaturalLineLength gets the natural size for each line.
//
// The function returns the following values:
//
//   - gint: natural length.
func (self *WrapBox) NaturalLineLength() int {
	var _arg0 *C.AdwWrapBox // out
	var _cret C.int         // in

	_arg0 = (*C.AdwWrapBox)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_wrap_box_get_natural_line_length(_arg0)
	runtime.KeepAlive(self)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// NaturalLineLengthUnit gets the length unit for line spacing.
//
// The function returns the following values:
//
//   - lengthUnit: length unit.
func (self *WrapBox) NaturalLineLengthUnit() LengthUnit {
	var _arg0 *C.AdwWrapBox   // out
	var _cret C.AdwLengthUnit // in

	_arg0 = (*C.AdwWrapBox)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_wrap_box_get_natural_line_length_unit(_arg0)
	runtime.KeepAlive(self)

	var _lengthUnit LengthUnit // out

	_lengthUnit = LengthUnit(_cret)

	return _lengthUnit
}

// PackDirection gets the direction children are packed in each line.
//
// The function returns the following values:
//
//   - packDirection: line direction.
func (self *WrapBox) PackDirection() PackDirection {
	var _arg0 *C.AdwWrapBox      // out
	var _cret C.AdwPackDirection // in

	_arg0 = (*C.AdwWrapBox)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_wrap_box_get_pack_direction(_arg0)
	runtime.KeepAlive(self)

	var _packDirection PackDirection // out

	_packDirection = PackDirection(_cret)

	return _packDirection
}

// WrapPolicy gets the policy for line wrapping.
//
// The function returns the following values:
//
//   - wrapPolicy: wrap policy.
func (self *WrapBox) WrapPolicy() WrapPolicy {
	var _arg0 *C.AdwWrapBox   // out
	var _cret C.AdwWrapPolicy // in

	_arg0 = (*C.AdwWrapBox)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_wrap_box_get_wrap_policy(_arg0)
	runtime.KeepAlive(self)

	var _wrapPolicy WrapPolicy // out

	_wrapPolicy = WrapPolicy(_cret)

	return _wrapPolicy
}

// WrapReverse gets whether wrap direction is reversed.
//
// The function returns the following values:
//
//   - ok: whether wrap direction is reversed.
func (self *WrapBox) WrapReverse() bool {
	var _arg0 *C.AdwWrapBox // out
	var _cret C.gboolean    // in

	_arg0 = (*C.AdwWrapBox)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_wrap_box_get_wrap_reverse(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// InsertChildAfter inserts child in the position after sibling in the list of
// self children.
//
// If sibling is NULL, inserts child at the first position.
//
// The function takes the following parameters:
//
//   - child: widget to insert.
//   - sibling (optional) after which to insert child.
func (self *WrapBox) InsertChildAfter(child, sibling gtk.Widgetter) {
	var _arg0 *C.AdwWrapBox // out
	var _arg1 *C.GtkWidget  // out
	var _arg2 *C.GtkWidget  // out

	_arg0 = (*C.AdwWrapBox)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	if sibling != nil {
		_arg2 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(sibling).Native()))
	}

	C.adw_wrap_box_insert_child_after(_arg0, _arg1, _arg2)
	runtime.KeepAlive(self)
	runtime.KeepAlive(child)
	runtime.KeepAlive(sibling)
}

// Prepend adds child as the first child to self.
//
// The function takes the following parameters:
//
//   - child: widget to prepend.
func (self *WrapBox) Prepend(child gtk.Widgetter) {
	var _arg0 *C.AdwWrapBox // out
	var _arg1 *C.GtkWidget  // out

	_arg0 = (*C.AdwWrapBox)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	C.adw_wrap_box_prepend(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(child)
}

// Remove removes a child widget from self.
//
// The child must have been added before with adw.WrapBox.Append(),
// adw.WrapBox.Prepend(), or adw.WrapBox.InsertChildAfter().
//
// The function takes the following parameters:
//
//   - child to remove.
func (self *WrapBox) Remove(child gtk.Widgetter) {
	var _arg0 *C.AdwWrapBox // out
	var _arg1 *C.GtkWidget  // out

	_arg0 = (*C.AdwWrapBox)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	C.adw_wrap_box_remove(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(child)
}

// ReorderChildAfter moves child to the position after sibling in the list of
// self children.
//
// If sibling is NULL, moves child to the first position.
//
// The function takes the following parameters:
//
//   - child: widget to move, must be a child of self.
//   - sibling (optional) to move child after.
func (self *WrapBox) ReorderChildAfter(child, sibling gtk.Widgetter) {
	var _arg0 *C.AdwWrapBox // out
	var _arg1 *C.GtkWidget  // out
	var _arg2 *C.GtkWidget  // out

	_arg0 = (*C.AdwWrapBox)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	if sibling != nil {
		_arg2 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(sibling).Native()))
	}

	C.adw_wrap_box_reorder_child_after(_arg0, _arg1, _arg2)
	runtime.KeepAlive(self)
	runtime.KeepAlive(child)
	runtime.KeepAlive(sibling)
}

// SetAlign sets the alignment of the children within each line.
//
// 0 means the children are placed at the start of the line, 1 means they are
// placed at the end of the line. 0.5 means they are placed in the middle of the
// line.
//
// Alignment is only used when wrapbox:justify is set to ADW_JUSTIFY_NONE,
// or on the last line when the wrapbox:justify-last-line is FALSE.
//
// The function takes the following parameters:
//
//   - align: child alignment.
func (self *WrapBox) SetAlign(align float32) {
	var _arg0 *C.AdwWrapBox // out
	var _arg1 C.float       // out

	_arg0 = (*C.AdwWrapBox)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.float(align)

	C.adw_wrap_box_set_align(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(align)
}

// SetChildSpacing sets the spacing between widgets on the same line.
//
// See wrapbox:child-spacing-unit.
//
// The function takes the following parameters:
//
//   - childSpacing: child spacing.
func (self *WrapBox) SetChildSpacing(childSpacing int) {
	var _arg0 *C.AdwWrapBox // out
	var _arg1 C.int         // out

	_arg0 = (*C.AdwWrapBox)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.int(childSpacing)

	C.adw_wrap_box_set_child_spacing(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(childSpacing)
}

// SetChildSpacingUnit sets the length unit for child spacing.
//
// Allows the spacing to vary depending on the text scale factor.
//
// See wrapbox:child-spacing.
//
// The function takes the following parameters:
//
//   - unit: length unit.
func (self *WrapBox) SetChildSpacingUnit(unit LengthUnit) {
	var _arg0 *C.AdwWrapBox   // out
	var _arg1 C.AdwLengthUnit // out

	_arg0 = (*C.AdwWrapBox)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.AdwLengthUnit(unit)

	C.adw_wrap_box_set_child_spacing_unit(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(unit)
}

// SetJustify determines whether and how each complete line should be stretched
// to fill the entire widget.
//
// If set to ADW_JUSTIFY_FILL, each widget in the line will be stretched,
// keeping consistent spacing, so that the line fills the entire widget.
//
// If set to ADW_JUSTIFY_SPREAD, the spacing between widgets will be increased,
// keeping widget sizes intact. The first and last widget will be aligned with
// the beginning and end of the line. If the line only contains a single widget,
// it will be stretched regardless.
//
// If set to ADW_JUSTIFY_NONE, the line will not be stretched and the children
// will be placed together within the line, according to wrapbox:align.
//
// By default this doesn't affect the last line, as it will be incomplete.
// Use wrapbox:justify-last-line to justify it as well.
//
// The function takes the following parameters:
//
//   - justify mode.
func (self *WrapBox) SetJustify(justify JustifyMode) {
	var _arg0 *C.AdwWrapBox    // out
	var _arg1 C.AdwJustifyMode // out

	_arg0 = (*C.AdwWrapBox)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.AdwJustifyMode(justify)

	C.adw_wrap_box_set_justify(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(justify)
}

// SetJustifyLastLine sets whether the last line should be stretched to fill the
// entire widget.
//
// See wrapbox:justify.
//
// The function takes the following parameters:
//
//   - justifyLastLine: whether to justify the last line.
func (self *WrapBox) SetJustifyLastLine(justifyLastLine bool) {
	var _arg0 *C.AdwWrapBox // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.AdwWrapBox)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if justifyLastLine {
		_arg1 = C.TRUE
	}

	C.adw_wrap_box_set_justify_last_line(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(justifyLastLine)
}

// SetLineHomogeneous sets whether all lines should take the same amount of
// space.
//
// The function takes the following parameters:
//
//   - homogeneous: whether lines should be homogeneous.
func (self *WrapBox) SetLineHomogeneous(homogeneous bool) {
	var _arg0 *C.AdwWrapBox // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.AdwWrapBox)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if homogeneous {
		_arg1 = C.TRUE
	}

	C.adw_wrap_box_set_line_homogeneous(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(homogeneous)
}

// SetLineSpacing sets the spacing between lines.
//
// The function takes the following parameters:
//
//   - lineSpacing: line spacing.
func (self *WrapBox) SetLineSpacing(lineSpacing int) {
	var _arg0 *C.AdwWrapBox // out
	var _arg1 C.int         // out

	_arg0 = (*C.AdwWrapBox)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.int(lineSpacing)

	C.adw_wrap_box_set_line_spacing(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(lineSpacing)
}

// SetLineSpacingUnit sets the length unit for line spacing.
//
// Allows the spacing to vary depending on the text scale factor.
//
// See wrapbox:line-spacing.
//
// The function takes the following parameters:
//
//   - unit: length unit.
func (self *WrapBox) SetLineSpacingUnit(unit LengthUnit) {
	var _arg0 *C.AdwWrapBox   // out
	var _arg1 C.AdwLengthUnit // out

	_arg0 = (*C.AdwWrapBox)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.AdwLengthUnit(unit)

	C.adw_wrap_box_set_line_spacing_unit(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(unit)
}

// SetNaturalLineLength sets the natural size for each line.
//
// It should be used to limit the line lengths, for example when used in
// popovers.
//
// See wrapbox:natural-line-length-unit.
//
// The function takes the following parameters:
//
//   - naturalLineLength: natural length.
func (self *WrapBox) SetNaturalLineLength(naturalLineLength int) {
	var _arg0 *C.AdwWrapBox // out
	var _arg1 C.int         // out

	_arg0 = (*C.AdwWrapBox)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.int(naturalLineLength)

	C.adw_wrap_box_set_natural_line_length(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(naturalLineLength)
}

// SetNaturalLineLengthUnit sets the length unit for natural line length.
//
// Allows the length to vary depending on the text scale factor.
//
// See wrapbox:natural-line-length.
//
// The function takes the following parameters:
//
//   - unit: length unit.
func (self *WrapBox) SetNaturalLineLengthUnit(unit LengthUnit) {
	var _arg0 *C.AdwWrapBox   // out
	var _arg1 C.AdwLengthUnit // out

	_arg0 = (*C.AdwWrapBox)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.AdwLengthUnit(unit)

	C.adw_wrap_box_set_natural_line_length_unit(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(unit)
}

// SetPackDirection sets the direction children are packed in each line.
//
// The function takes the following parameters:
//
//   - packDirection: new line direction.
func (self *WrapBox) SetPackDirection(packDirection PackDirection) {
	var _arg0 *C.AdwWrapBox      // out
	var _arg1 C.AdwPackDirection // out

	_arg0 = (*C.AdwWrapBox)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.AdwPackDirection(packDirection)

	C.adw_wrap_box_set_pack_direction(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(packDirection)
}

// SetWrapPolicy sets the policy for line wrapping.
//
// If set to ADW_WRAP_NATURAL, the box will wrap to the next line as soon as the
// previous line cannot fit any more children without shrinking them past their
// natural size.
//
// If set to ADW_WRAP_MINIMUM, the box will try to fit as many children into
// each line as possible, shrinking them down to their minimum size before
// wrapping to the next line.
//
// The function takes the following parameters:
//
//   - wrapPolicy: new wrap policy.
func (self *WrapBox) SetWrapPolicy(wrapPolicy WrapPolicy) {
	var _arg0 *C.AdwWrapBox   // out
	var _arg1 C.AdwWrapPolicy // out

	_arg0 = (*C.AdwWrapBox)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.AdwWrapPolicy(wrapPolicy)

	C.adw_wrap_box_set_wrap_policy(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(wrapPolicy)
}

// SetWrapReverse sets whether wrap direction should be reversed.
//
// By default, lines wrap downwards in a horizontal box, and towards the end
// in a vertical box. If set to TRUE, they wrap upwards or towards the start
// respectively.
//
// The function takes the following parameters:
//
//   - wrapReverse: whether to reverse wrap direction.
func (self *WrapBox) SetWrapReverse(wrapReverse bool) {
	var _arg0 *C.AdwWrapBox // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.AdwWrapBox)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if wrapReverse {
		_arg1 = C.TRUE
	}

	C.adw_wrap_box_set_wrap_reverse(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(wrapReverse)
}
