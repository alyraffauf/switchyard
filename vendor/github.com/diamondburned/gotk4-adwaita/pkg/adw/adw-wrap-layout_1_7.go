// Code generated by girgen. DO NOT EDIT.

package adw

import (
	"fmt"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gtk/v4"
)

// #include <stdlib.h>
// #include <adwaita.h>
// #include <glib-object.h>
import "C"

// GType values.
var (
	GTypeJustifyMode   = coreglib.Type(C.adw_justify_mode_get_type())
	GTypePackDirection = coreglib.Type(C.adw_pack_direction_get_type())
	GTypeWrapPolicy    = coreglib.Type(C.adw_wrap_policy_get_type())
	GTypeWrapLayout    = coreglib.Type(C.adw_wrap_layout_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeJustifyMode, F: marshalJustifyMode},
		coreglib.TypeMarshaler{T: GTypePackDirection, F: marshalPackDirection},
		coreglib.TypeMarshaler{T: GTypeWrapPolicy, F: marshalWrapPolicy},
		coreglib.TypeMarshaler{T: GTypeWrapLayout, F: marshalWrapLayout},
	})
}

// JustifyMode describes line justify behaviors in a wraplayout or wrapbox.
//
// See wraplayout:justify and wrapbox:justify.
type JustifyMode C.gint

const (
	// JustifyNone: don't justify children within a line.
	JustifyNone JustifyMode = iota
	// JustifyFill: stretch each child within the line, keeping consistent
	// spacing, so that the line fills the entire length.
	JustifyFill
	// JustifySpread: increase spacing between children, moving the children so
	// that the first and last child are aligned with the beginning and end of
	// the line. If the line only contains a single widget, it will be stretched
	// regardless.
	JustifySpread
)

func marshalJustifyMode(p uintptr) (interface{}, error) {
	return JustifyMode(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for JustifyMode.
func (j JustifyMode) String() string {
	switch j {
	case JustifyNone:
		return "None"
	case JustifyFill:
		return "Fill"
	case JustifySpread:
		return "Spread"
	default:
		return fmt.Sprintf("JustifyMode(%d)", j)
	}
}

// PackDirection describes child packing behavior in a wraplayout or wrapbox.
//
// See wraplayout:pack-direction and wrapbox:pack-direction.
type PackDirection C.gint

const (
	// PackStartToEnd: pack children from left to right for LTR languages,
	// or top to bottom vertically.
	PackStartToEnd PackDirection = iota
	// PackEndToStart: pack children from right to left for LTR languages,
	// or bottom to top vertically.
	PackEndToStart
)

func marshalPackDirection(p uintptr) (interface{}, error) {
	return PackDirection(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for PackDirection.
func (p PackDirection) String() string {
	switch p {
	case PackStartToEnd:
		return "StartToEnd"
	case PackEndToStart:
		return "EndToStart"
	default:
		return fmt.Sprintf("PackDirection(%d)", p)
	}
}

// WrapPolicy describes line wrapping behavior in a wraplayout or wrapbox.
//
// See wraplayout:wrap-policy and wrapbox:wrap-policy.
type WrapPolicy C.gint

const (
	// WrapMinimum: fit as many children into each line as possible, shrinking
	// them down to their minimum size before wrapping to the next line.
	WrapMinimum WrapPolicy = iota
	// WrapNatural: wrap to the next line as soon as the previous line cannot
	// fit any more children without shrinking them past their natural size.
	WrapNatural
)

func marshalWrapPolicy(p uintptr) (interface{}, error) {
	return WrapPolicy(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for WrapPolicy.
func (w WrapPolicy) String() string {
	switch w {
	case WrapMinimum:
		return "Minimum"
	case WrapNatural:
		return "Natural"
	default:
		return fmt.Sprintf("WrapPolicy(%d)", w)
	}
}

// WrapLayoutOverrides contains methods that are overridable.
type WrapLayoutOverrides struct {
}

func defaultWrapLayoutOverrides(v *WrapLayout) WrapLayoutOverrides {
	return WrapLayoutOverrides{}
}

// WrapLayout: box-like layout that can wrap into multiple lines.
//
// <picture> <source srcset="wrap-box-dark.png" media="(prefers-color-scheme:
// dark)"> <img src="wrap-box.png" alt="wrap-box"> </picture>
//
// AdwWrapLayout is similar to gtk.BoxLayout, but can wrap lines when the
// widgets cannot fit otherwise. Unlike gtk.FlowBox, the children aren't
// arranged into a grid and behave more like words in a wrapping label.
//
// Like GtkBoxLayout, AdwWrapLayout is orientable and has spacing:
//
// - wraplayout:child-spacing between children in the same line;
//
// - wraplayout:line-spacing between lines.
//
// ::: note Unlike GtkBoxLayout, AdwWrapLayout cannot follow the CSS
// border-spacing property.
//
// Use the wraplayout:natural-line-length property to determine the layout's
// natural size, e.g. when using it in a gtk.Popover.
//
// Normally, a horizontal AdwWrapLayout wraps left to right and top to bottom
// for left-to-right languages. Both of these directions can be reversed,
// using the wraplayout:pack-direction and wraplayout:wrap-reverse properties.
// Additionally, the alignment of each line can be controlled with the
// wraplayout:align property.
//
// Lines can be justified using the wraplayout:justify property, filling the
// entire line by either increasing child size or spacing depending on the
// value. Set wraplayout:justify-last-line to justify the last line as well.
//
// By default, AdwWrapLayout wraps as soon as the previous line cannot fit
// any more children without shrinking them past their natural size. Set
// wraplayout:wrap-policy to adw.WrapPolicy.MINIMUM to only wrap once all the
// children in the previous line have been shrunk to their minimum size.
//
// To make each line take the same amount of space, set
// wraplayout:line-homogeneous to TRUE.
//
// Spacing and natural line length can scale with the text scale factor,
// use the wraplayout:child-spacing-unit, wraplayout:line-spacing-unit and/or
// wraplayout:natural-line-length-unit properties to enable that behavior.
//
// See wrapbox.
type WrapLayout struct {
	_ [0]func() // equal guard
	gtk.LayoutManager

	*coreglib.Object
	gtk.Orientable
}

var (
	_ gtk.LayoutManagerer = (*WrapLayout)(nil)
	_ coreglib.Objector   = (*WrapLayout)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*WrapLayout, *WrapLayoutClass, WrapLayoutOverrides](
		GTypeWrapLayout,
		initWrapLayoutClass,
		wrapWrapLayout,
		defaultWrapLayoutOverrides,
	)
}

func initWrapLayoutClass(gclass unsafe.Pointer, overrides WrapLayoutOverrides, classInitFunc func(*WrapLayoutClass)) {
	if classInitFunc != nil {
		class := (*WrapLayoutClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapWrapLayout(obj *coreglib.Object) *WrapLayout {
	return &WrapLayout{
		LayoutManager: gtk.LayoutManager{
			Object: obj,
		},
		Object: obj,
		Orientable: gtk.Orientable{
			Object: obj,
		},
	}
}

func marshalWrapLayout(p uintptr) (interface{}, error) {
	return wrapWrapLayout(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewWrapLayout creates a new AdwWrapLayout.
//
// The function returns the following values:
//
//   - wrapLayout: newly created AdwWrapLayout.
func NewWrapLayout() *WrapLayout {
	var _cret *C.GtkLayoutManager // in

	_cret = C.adw_wrap_layout_new()

	var _wrapLayout *WrapLayout // out

	_wrapLayout = wrapWrapLayout(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _wrapLayout
}

// Align gets the alignment of the children within each line.
//
// The function returns the following values:
//
//   - gfloat: child alignment.
func (self *WrapLayout) Align() float32 {
	var _arg0 *C.AdwWrapLayout // out
	var _cret C.float          // in

	_arg0 = (*C.AdwWrapLayout)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_wrap_layout_get_align(_arg0)
	runtime.KeepAlive(self)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// ChildSpacing gets spacing between widgets on the same line.
//
// The function returns the following values:
//
//   - gint: spacing between widgets on the same line.
func (self *WrapLayout) ChildSpacing() int {
	var _arg0 *C.AdwWrapLayout // out
	var _cret C.int            // in

	_arg0 = (*C.AdwWrapLayout)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_wrap_layout_get_child_spacing(_arg0)
	runtime.KeepAlive(self)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// ChildSpacingUnit gets the length unit for child spacing.
//
// The function returns the following values:
//
//   - lengthUnit: length unit.
func (self *WrapLayout) ChildSpacingUnit() LengthUnit {
	var _arg0 *C.AdwWrapLayout // out
	var _cret C.AdwLengthUnit  // in

	_arg0 = (*C.AdwWrapLayout)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_wrap_layout_get_child_spacing_unit(_arg0)
	runtime.KeepAlive(self)

	var _lengthUnit LengthUnit // out

	_lengthUnit = LengthUnit(_cret)

	return _lengthUnit
}

// Justify gets whether and how each complete line is stretched to fill the
// entire widget.
//
// The function returns the following values:
//
//   - justifyMode: justify mode.
func (self *WrapLayout) Justify() JustifyMode {
	var _arg0 *C.AdwWrapLayout // out
	var _cret C.AdwJustifyMode // in

	_arg0 = (*C.AdwWrapLayout)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_wrap_layout_get_justify(_arg0)
	runtime.KeepAlive(self)

	var _justifyMode JustifyMode // out

	_justifyMode = JustifyMode(_cret)

	return _justifyMode
}

// JustifyLastLine gets whether the last line should be stretched to fill the
// entire widget.
//
// The function returns the following values:
//
//   - ok: whether the last line is justified.
func (self *WrapLayout) JustifyLastLine() bool {
	var _arg0 *C.AdwWrapLayout // out
	var _cret C.gboolean       // in

	_arg0 = (*C.AdwWrapLayout)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_wrap_layout_get_justify_last_line(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// LineHomogeneous gets whether all lines should take the same amount of space.
//
// The function returns the following values:
//
//   - ok: whether lines should be homogeneous.
func (self *WrapLayout) LineHomogeneous() bool {
	var _arg0 *C.AdwWrapLayout // out
	var _cret C.gboolean       // in

	_arg0 = (*C.AdwWrapLayout)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_wrap_layout_get_line_homogeneous(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// LineSpacing gets the spacing between lines.
//
// The function returns the following values:
//
//   - gint: line spacing.
func (self *WrapLayout) LineSpacing() int {
	var _arg0 *C.AdwWrapLayout // out
	var _cret C.int            // in

	_arg0 = (*C.AdwWrapLayout)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_wrap_layout_get_line_spacing(_arg0)
	runtime.KeepAlive(self)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// LineSpacingUnit gets the length unit for line spacing.
//
// The function returns the following values:
//
//   - lengthUnit: length unit.
func (self *WrapLayout) LineSpacingUnit() LengthUnit {
	var _arg0 *C.AdwWrapLayout // out
	var _cret C.AdwLengthUnit  // in

	_arg0 = (*C.AdwWrapLayout)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_wrap_layout_get_line_spacing_unit(_arg0)
	runtime.KeepAlive(self)

	var _lengthUnit LengthUnit // out

	_lengthUnit = LengthUnit(_cret)

	return _lengthUnit
}

// NaturalLineLength gets the natural size for each line.
//
// The function returns the following values:
//
//   - gint: natural length.
func (self *WrapLayout) NaturalLineLength() int {
	var _arg0 *C.AdwWrapLayout // out
	var _cret C.int            // in

	_arg0 = (*C.AdwWrapLayout)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_wrap_layout_get_natural_line_length(_arg0)
	runtime.KeepAlive(self)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// NaturalLineLengthUnit gets the length unit for line spacing.
//
// The function returns the following values:
//
//   - lengthUnit: length unit.
func (self *WrapLayout) NaturalLineLengthUnit() LengthUnit {
	var _arg0 *C.AdwWrapLayout // out
	var _cret C.AdwLengthUnit  // in

	_arg0 = (*C.AdwWrapLayout)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_wrap_layout_get_natural_line_length_unit(_arg0)
	runtime.KeepAlive(self)

	var _lengthUnit LengthUnit // out

	_lengthUnit = LengthUnit(_cret)

	return _lengthUnit
}

// PackDirection gets the direction children are packed in each line.
//
// The function returns the following values:
//
//   - packDirection: line direction.
func (self *WrapLayout) PackDirection() PackDirection {
	var _arg0 *C.AdwWrapLayout   // out
	var _cret C.AdwPackDirection // in

	_arg0 = (*C.AdwWrapLayout)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_wrap_layout_get_pack_direction(_arg0)
	runtime.KeepAlive(self)

	var _packDirection PackDirection // out

	_packDirection = PackDirection(_cret)

	return _packDirection
}

// WrapPolicy gets the policy for line wrapping.
//
// The function returns the following values:
//
//   - wrapPolicy: wrap policy.
func (self *WrapLayout) WrapPolicy() WrapPolicy {
	var _arg0 *C.AdwWrapLayout // out
	var _cret C.AdwWrapPolicy  // in

	_arg0 = (*C.AdwWrapLayout)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_wrap_layout_get_wrap_policy(_arg0)
	runtime.KeepAlive(self)

	var _wrapPolicy WrapPolicy // out

	_wrapPolicy = WrapPolicy(_cret)

	return _wrapPolicy
}

// WrapReverse gets whether wrap direction is reversed.
//
// The function returns the following values:
//
//   - ok: whether wrap direction is reversed.
func (self *WrapLayout) WrapReverse() bool {
	var _arg0 *C.AdwWrapLayout // out
	var _cret C.gboolean       // in

	_arg0 = (*C.AdwWrapLayout)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_wrap_layout_get_wrap_reverse(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetAlign sets the alignment of the children within each line.
//
// 0 means the children are placed at the start of the line, 1 means they are
// placed at the end of the line. 0.5 means they are placed in the middle of the
// line.
//
// Alignment is only used when wraplayout:justify is set to ADW_JUSTIFY_NONE,
// or on the last line when the wraplayout:justify-last-line is FALSE.
//
// The function takes the following parameters:
//
//   - align: child alignment.
func (self *WrapLayout) SetAlign(align float32) {
	var _arg0 *C.AdwWrapLayout // out
	var _arg1 C.float          // out

	_arg0 = (*C.AdwWrapLayout)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.float(align)

	C.adw_wrap_layout_set_align(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(align)
}

// SetChildSpacing sets the spacing between widgets on the same line.
//
// See wraplayout:child-spacing-unit.
//
// The function takes the following parameters:
//
//   - childSpacing: child spacing.
func (self *WrapLayout) SetChildSpacing(childSpacing int) {
	var _arg0 *C.AdwWrapLayout // out
	var _arg1 C.int            // out

	_arg0 = (*C.AdwWrapLayout)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.int(childSpacing)

	C.adw_wrap_layout_set_child_spacing(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(childSpacing)
}

// SetChildSpacingUnit sets the length unit for child spacing.
//
// Allows the spacing to vary depending on the text scale factor.
//
// See wraplayout:child-spacing.
//
// The function takes the following parameters:
//
//   - unit: length unit.
func (self *WrapLayout) SetChildSpacingUnit(unit LengthUnit) {
	var _arg0 *C.AdwWrapLayout // out
	var _arg1 C.AdwLengthUnit  // out

	_arg0 = (*C.AdwWrapLayout)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.AdwLengthUnit(unit)

	C.adw_wrap_layout_set_child_spacing_unit(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(unit)
}

// SetJustify sets whether and how each complete line should be stretched to
// fill the entire widget.
//
// If set to ADW_JUSTIFY_FILL, each widget in the line will be stretched,
// keeping consistent spacing, so that the line fills the entire widget.
//
// If set to ADW_JUSTIFY_SPREAD, the spacing between widgets will be increased,
// keeping widget sizes intact. The first and last widget will be aligned with
// the beginning and end of the line. If the line only contains a single widget,
// it will be stretched regardless.
//
// If set to ADW_JUSTIFY_NONE, the line will not be stretched and the children
// will be placed together within the line, according to wraplayout:align.
//
// By default this doesn't affect the last line, as it will be incomplete.
// Use wraplayout:justify-last-line to justify it as well.
//
// The function takes the following parameters:
//
//   - justify mode.
func (self *WrapLayout) SetJustify(justify JustifyMode) {
	var _arg0 *C.AdwWrapLayout // out
	var _arg1 C.AdwJustifyMode // out

	_arg0 = (*C.AdwWrapLayout)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.AdwJustifyMode(justify)

	C.adw_wrap_layout_set_justify(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(justify)
}

// SetJustifyLastLine sets whether the last line should be stretched to fill the
// entire widget.
//
// See wraplayout:justify.
//
// The function takes the following parameters:
//
//   - justifyLastLine: whether to justify the last line.
func (self *WrapLayout) SetJustifyLastLine(justifyLastLine bool) {
	var _arg0 *C.AdwWrapLayout // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.AdwWrapLayout)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if justifyLastLine {
		_arg1 = C.TRUE
	}

	C.adw_wrap_layout_set_justify_last_line(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(justifyLastLine)
}

// SetLineHomogeneous sets whether all lines should take the same amount of
// space.
//
// The function takes the following parameters:
//
//   - homogeneous: whether lines should be homogeneous.
func (self *WrapLayout) SetLineHomogeneous(homogeneous bool) {
	var _arg0 *C.AdwWrapLayout // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.AdwWrapLayout)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if homogeneous {
		_arg1 = C.TRUE
	}

	C.adw_wrap_layout_set_line_homogeneous(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(homogeneous)
}

// SetLineSpacing sets the spacing between lines.
//
// See wraplayout:line-spacing-unit.
//
// The function takes the following parameters:
//
//   - lineSpacing: line spacing.
func (self *WrapLayout) SetLineSpacing(lineSpacing int) {
	var _arg0 *C.AdwWrapLayout // out
	var _arg1 C.int            // out

	_arg0 = (*C.AdwWrapLayout)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.int(lineSpacing)

	C.adw_wrap_layout_set_line_spacing(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(lineSpacing)
}

// SetLineSpacingUnit sets the length unit for line spacing.
//
// Allows the spacing to vary depending on the text scale factor.
//
// See wraplayout:line-spacing.
//
// The function takes the following parameters:
//
//   - unit: length unit.
func (self *WrapLayout) SetLineSpacingUnit(unit LengthUnit) {
	var _arg0 *C.AdwWrapLayout // out
	var _arg1 C.AdwLengthUnit  // out

	_arg0 = (*C.AdwWrapLayout)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.AdwLengthUnit(unit)

	C.adw_wrap_layout_set_line_spacing_unit(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(unit)
}

// SetNaturalLineLength sets the natural size for each line.
//
// It should be used to limit the line lengths, for example when used in
// popovers.
//
// See wraplayout:natural-line-length-unit.
//
// The function takes the following parameters:
//
//   - naturalLineLength: natural length.
func (self *WrapLayout) SetNaturalLineLength(naturalLineLength int) {
	var _arg0 *C.AdwWrapLayout // out
	var _arg1 C.int            // out

	_arg0 = (*C.AdwWrapLayout)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.int(naturalLineLength)

	C.adw_wrap_layout_set_natural_line_length(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(naturalLineLength)
}

// SetNaturalLineLengthUnit sets the length unit for natural line length.
//
// Allows the length to vary depending on the text scale factor.
//
// See wraplayout:natural-line-length.
//
// The function takes the following parameters:
//
//   - unit: length unit.
func (self *WrapLayout) SetNaturalLineLengthUnit(unit LengthUnit) {
	var _arg0 *C.AdwWrapLayout // out
	var _arg1 C.AdwLengthUnit  // out

	_arg0 = (*C.AdwWrapLayout)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.AdwLengthUnit(unit)

	C.adw_wrap_layout_set_natural_line_length_unit(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(unit)
}

// SetPackDirection sets the direction children are packed in each line.
//
// The function takes the following parameters:
//
//   - packDirection: new line direction.
func (self *WrapLayout) SetPackDirection(packDirection PackDirection) {
	var _arg0 *C.AdwWrapLayout   // out
	var _arg1 C.AdwPackDirection // out

	_arg0 = (*C.AdwWrapLayout)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.AdwPackDirection(packDirection)

	C.adw_wrap_layout_set_pack_direction(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(packDirection)
}

// SetWrapPolicy sets the policy for line wrapping.
//
// If set to ADW_WRAP_NATURAL, the box will wrap to the next line as soon as the
// previous line cannot fit any more children without shrinking them past their
// natural size.
//
// If set to ADW_WRAP_MINIMUM, the box will try to fit as many children into
// each line as possible, shrinking them down to their minimum size before
// wrapping to the next line.
//
// The function takes the following parameters:
//
//   - wrapPolicy: new wrap policy.
func (self *WrapLayout) SetWrapPolicy(wrapPolicy WrapPolicy) {
	var _arg0 *C.AdwWrapLayout // out
	var _arg1 C.AdwWrapPolicy  // out

	_arg0 = (*C.AdwWrapLayout)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.AdwWrapPolicy(wrapPolicy)

	C.adw_wrap_layout_set_wrap_policy(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(wrapPolicy)
}

// SetWrapReverse sets whether wrap direction should be reversed.
//
// By default, lines wrap downwards in a horizontal box, and towards the end
// in a vertical box. If set to TRUE, they wrap upwards or towards the start
// respectively.
//
// The function takes the following parameters:
//
//   - wrapReverse: whether to reverse wrap direction.
func (self *WrapLayout) SetWrapReverse(wrapReverse bool) {
	var _arg0 *C.AdwWrapLayout // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.AdwWrapLayout)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if wrapReverse {
		_arg1 = C.TRUE
	}

	C.adw_wrap_layout_set_wrap_reverse(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(wrapReverse)
}
