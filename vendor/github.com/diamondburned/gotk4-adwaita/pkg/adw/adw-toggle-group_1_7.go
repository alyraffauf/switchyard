// Code generated by girgen. DO NOT EDIT.

package adw

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	"github.com/diamondburned/gotk4/pkg/gtk/v4"
)

// #include <stdlib.h>
// #include <adwaita.h>
// #include <glib-object.h>
import "C"

// GType values.
var (
	GTypeToggle      = coreglib.Type(C.adw_toggle_get_type())
	GTypeToggleGroup = coreglib.Type(C.adw_toggle_group_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeToggle, F: marshalToggle},
		coreglib.TypeMarshaler{T: GTypeToggleGroup, F: marshalToggleGroup},
	})
}

// ToggleOverrides contains methods that are overridable.
type ToggleOverrides struct {
}

func defaultToggleOverrides(v *Toggle) ToggleOverrides {
	return ToggleOverrides{}
}

// Toggle: toggle within togglegroup.
//
// AdwToggle can optionally have a name, set with toggle:name. If the name is
// set, togglegroup:active-name can be used to access toggles instead of index.
type Toggle struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Toggle)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*Toggle, *ToggleClass, ToggleOverrides](
		GTypeToggle,
		initToggleClass,
		wrapToggle,
		defaultToggleOverrides,
	)
}

func initToggleClass(gclass unsafe.Pointer, overrides ToggleOverrides, classInitFunc func(*ToggleClass)) {
	if classInitFunc != nil {
		class := (*ToggleClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapToggle(obj *coreglib.Object) *Toggle {
	return &Toggle{
		Object: obj,
	}
}

func marshalToggle(p uintptr) (interface{}, error) {
	return wrapToggle(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewToggle creates a new AdwToggle.
//
// The function returns the following values:
//
//   - toggle: newly created AdwToggle.
func NewToggle() *Toggle {
	var _cret *C.AdwToggle // in

	_cret = C.adw_toggle_new()

	var _toggle *Toggle // out

	_toggle = wrapToggle(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _toggle
}

// Child gets the child widget of self.
//
// The function returns the following values:
//
//   - widget (optional): toggle child.
func (self *Toggle) Child() gtk.Widgetter {
	var _arg0 *C.AdwToggle // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.AdwToggle)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_toggle_get_child(_arg0)
	runtime.KeepAlive(self)

	var _widget gtk.Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(gtk.Widgetter)
				return ok
			})
			rv, ok := casted.(gtk.Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// Enabled gets whether self is enabled.
//
// The function returns the following values:
//
//   - ok: whether the toggle is enabled.
func (self *Toggle) Enabled() bool {
	var _arg0 *C.AdwToggle // out
	var _cret C.gboolean   // in

	_arg0 = (*C.AdwToggle)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_toggle_get_enabled(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IconName gets the icon name of self.
//
// The function returns the following values:
//
//   - utf8 (optional): toggle icon name.
func (self *Toggle) IconName() string {
	var _arg0 *C.AdwToggle // out
	var _cret *C.char      // in

	_arg0 = (*C.AdwToggle)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_toggle_get_icon_name(_arg0)
	runtime.KeepAlive(self)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Index gets the index of self within its toggle group.
//
// The function returns the following values:
//
//   - guint: index, or GTK_INVALID_LIST_POSITION if it's not in a group.
func (self *Toggle) Index() uint {
	var _arg0 *C.AdwToggle // out
	var _cret C.guint      // in

	_arg0 = (*C.AdwToggle)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_toggle_get_index(_arg0)
	runtime.KeepAlive(self)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Label gets the label of self.
//
// The function returns the following values:
//
//   - utf8 (optional): toggle label.
func (self *Toggle) Label() string {
	var _arg0 *C.AdwToggle // out
	var _cret *C.char      // in

	_arg0 = (*C.AdwToggle)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_toggle_get_label(_arg0)
	runtime.KeepAlive(self)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Name gets the name of self.
//
// The function returns the following values:
//
//   - utf8: toggle name.
func (self *Toggle) Name() string {
	var _arg0 *C.AdwToggle // out
	var _cret *C.char      // in

	_arg0 = (*C.AdwToggle)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_toggle_get_name(_arg0)
	runtime.KeepAlive(self)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Tooltip gets the tooltip of self.
//
// The function returns the following values:
//
//   - utf8: toggle tooltip.
func (self *Toggle) Tooltip() string {
	var _arg0 *C.AdwToggle // out
	var _cret *C.char      // in

	_arg0 = (*C.AdwToggle)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_toggle_get_tooltip(_arg0)
	runtime.KeepAlive(self)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// UseUnderline gets whether self uses underlines.
//
// The function returns the following values:
//
//   - ok: whether the toggle uses underlines.
func (self *Toggle) UseUnderline() bool {
	var _arg0 *C.AdwToggle // out
	var _cret C.gboolean   // in

	_arg0 = (*C.AdwToggle)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_toggle_get_use_underline(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetChild sets the child of self to child.
//
// When the child is set, icon and label are not displayed.
//
// It's recommended to still set the label, as it can still be used by the
// screen reader.
//
// The function takes the following parameters:
//
//   - child (optional) widget.
func (self *Toggle) SetChild(child gtk.Widgetter) {
	var _arg0 *C.AdwToggle // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.AdwToggle)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if child != nil {
		_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	}

	C.adw_toggle_set_child(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(child)
}

// SetEnabled sets whether self is enabled.
//
// The function takes the following parameters:
//
//   - enabled: whether the toggle should be enbled.
func (self *Toggle) SetEnabled(enabled bool) {
	var _arg0 *C.AdwToggle // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.AdwToggle)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if enabled {
		_arg1 = C.TRUE
	}

	C.adw_toggle_set_enabled(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(enabled)
}

// SetIconName sets the icon name of self to icon_name.
//
// The icon will be displayed alone or next to the label, unless toggle:child is
// set.
//
// The function takes the following parameters:
//
//   - iconName (optional): icon name.
func (self *Toggle) SetIconName(iconName string) {
	var _arg0 *C.AdwToggle // out
	var _arg1 *C.char      // out

	_arg0 = (*C.AdwToggle)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if iconName != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(iconName)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.adw_toggle_set_icon_name(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(iconName)
}

// SetLabel sets the label of self to label.
//
// The label will be displayed alone or next to the icon, unless toggle:child is
// set, but will still be read out by the screen reader.
//
// The function takes the following parameters:
//
//   - label (optional): label.
func (self *Toggle) SetLabel(label string) {
	var _arg0 *C.AdwToggle // out
	var _arg1 *C.char      // out

	_arg0 = (*C.AdwToggle)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if label != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(label)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.adw_toggle_set_label(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(label)
}

// SetName sets the name of self to name.
//
// Allows accessing self by its name instead of index.
//
// See togglegroup:active-name.
//
// The function takes the following parameters:
//
//   - name (optional): name.
func (self *Toggle) SetName(name string) {
	var _arg0 *C.AdwToggle // out
	var _arg1 *C.char      // out

	_arg0 = (*C.AdwToggle)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if name != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.adw_toggle_set_name(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(name)
}

// SetTooltip sets the tooltip of self to tooltip.
//
// tooltip can be marked up with the Pango text markup language.
//
// The function takes the following parameters:
//
//   - tooltip: tooltip.
func (self *Toggle) SetTooltip(tooltip string) {
	var _arg0 *C.AdwToggle // out
	var _arg1 *C.char      // out

	_arg0 = (*C.AdwToggle)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(tooltip)))
	defer C.free(unsafe.Pointer(_arg1))

	C.adw_toggle_set_tooltip(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(tooltip)
}

// SetUseUnderline sets whether an embedded underline in the label indicates a
// mnemonic.
//
// See toggle:label.
//
// The function takes the following parameters:
//
//   - useUnderline: whether an underline in the label indicates a mnemonic.
func (self *Toggle) SetUseUnderline(useUnderline bool) {
	var _arg0 *C.AdwToggle // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.AdwToggle)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if useUnderline {
		_arg1 = C.TRUE
	}

	C.adw_toggle_set_use_underline(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(useUnderline)
}

// ToggleGroupOverrides contains methods that are overridable.
type ToggleGroupOverrides struct {
}

func defaultToggleGroupOverrides(v *ToggleGroup) ToggleGroupOverrides {
	return ToggleGroupOverrides{}
}

// ToggleGroup: group of exclusive toggles.
//
// <picture> <source srcset="toggle-group-dark.png"
// media="(prefers-color-scheme: dark)"> <img src="toggle-group.png"
// alt="toggle-group"> </picture>
//
// AdwToggleGroup presents a set of exclusive toggles, represented as toggle
// objects. Each toggle can display an icon, a label, an icon and a label,
// or a custom child.
//
// Toggles are indexed by their position, with the first toggle being equivalent
// to 0, and so on. Use the togglegroup:active to get that position.
//
// Toggles can also have optional names, set via the toggle:name property.
// The name of the active toggle can be accessed via the togglegroup:active-name
// property.
//
// AdwToggle objects can be retrieved via their index or name, using
// togglegroup.GetToggle or togglegroup.GetToggleByName respectively.
// AdwToggleGroup also provides a gtk.SelectionModel of its toggles via the
// togglegroup:toggles property.
//
// AdwToggleGroup is orientable, and the toggles can be displayed horizontally
// or vertically. This is mostly useful for icon-only toggles.
//
// Use the togglegroup:homogeneous property to make the toggles take the same
// size, and the togglegroup:can-shrink to control whether the toggles can
// ellipsize.
//
// Example of an AdwToggleGroup UI definition:
//
//	<object class="AdwToggleGroup">
//	  <property name="active-name">picture</property>
//	  <child>
//	    <object class="AdwToggle">
//	      <property name="icon-name">camera-photo-symbolic</property>
//	      <property name="tooltip" translatable="yes">Picture Mode</property>
//	      <property name="name">picture</property>
//	    </object>
//	  </child>
//	  <child>
//	    <object class="AdwToggle">
//	      <property name="icon-name">camera-video-symbolic</property>
//	      <property name="tooltip" translatable="yes">Recording Mode</property>
//	      <property name="name">recording</property>
//	    </object>
//	  </child>
//	</object>
//
// See also: inlineviewswitcher.
//
// # CSS nodes
//
// AdwToggleGroup has a main CSS node with the name toggle-group.
//
// Its toggles have CSS nodes with the name toggle, and its separators have
// nodes with the name separator.
//
// Toggle nodes will have a different style classes depending on their content:
// .text-button for labels, .image-button for icons, .image-text-button for both
// or no style class for custom children.
//
// The hidden separators use the .hidden style class.
//
// # Style classes
//
// AdwToggleGroup can use the .flat (style-classes.html#flat_1) style class to
// remove its background and make it look like a group of buttons.
//
// <picture> <source srcset="toggle-group-flat-dark.png"
// media="(prefers-color-scheme: dark)"> <img src="toggle-group-flat.png"
// alt="toggle-group-flat"> </picture>
//
// It can also use the .round (style-classes.html#round) style class to make its
// toggles and the group itself rounded.
//
// <picture> <source srcset="toggle-group-round-dark.png"
// media="(prefers-color-scheme: dark)"> <img src="toggle-group-round.png"
// alt="toggle-group-round"> </picture>
//
// They can also be combined with each other.
//
// <picture> <source srcset="toggle-group-flat-round-dark.png"
// media="(prefers-color-scheme: dark)"> <img src="toggle-group-flat-round.png"
// alt="toggle-group-flat-round"> </picture>
//
// # Accessibility
//
// AdwToggleGroup uses the GTK_ACCESSIBLE_ROLE_RADIO_GROUP role. Its toggles use
// the GTK_ACCESSIBLE_ROLE_RADIO role.
type ToggleGroup struct {
	_ [0]func() // equal guard
	gtk.Widget

	*coreglib.Object
	gtk.Orientable
}

var (
	_ gtk.Widgetter     = (*ToggleGroup)(nil)
	_ coreglib.Objector = (*ToggleGroup)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*ToggleGroup, *ToggleGroupClass, ToggleGroupOverrides](
		GTypeToggleGroup,
		initToggleGroupClass,
		wrapToggleGroup,
		defaultToggleGroupOverrides,
	)
}

func initToggleGroupClass(gclass unsafe.Pointer, overrides ToggleGroupOverrides, classInitFunc func(*ToggleGroupClass)) {
	if classInitFunc != nil {
		class := (*ToggleGroupClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapToggleGroup(obj *coreglib.Object) *ToggleGroup {
	return &ToggleGroup{
		Widget: gtk.Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: gtk.Accessible{
				Object: obj,
			},
			Buildable: gtk.Buildable{
				Object: obj,
			},
			ConstraintTarget: gtk.ConstraintTarget{
				Object: obj,
			},
		},
		Object: obj,
		Orientable: gtk.Orientable{
			Object: obj,
		},
	}
}

func marshalToggleGroup(p uintptr) (interface{}, error) {
	return wrapToggleGroup(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewToggleGroup creates a new AdwToggleGroup.
//
// The function returns the following values:
//
//   - toggleGroup: newly created AdwToggleGroup.
func NewToggleGroup() *ToggleGroup {
	var _cret *C.GtkWidget // in

	_cret = C.adw_toggle_group_new()

	var _toggleGroup *ToggleGroup // out

	_toggleGroup = wrapToggleGroup(coreglib.Take(unsafe.Pointer(_cret)))

	return _toggleGroup
}

// Add adds a toggle to self.
//
// The function takes the following parameters:
//
//   - toggle to add.
func (self *ToggleGroup) Add(toggle *Toggle) {
	var _arg0 *C.AdwToggleGroup // out
	var _arg1 *C.AdwToggle      // out

	_arg0 = (*C.AdwToggleGroup)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.AdwToggle)(unsafe.Pointer(coreglib.InternObject(toggle).Native()))
	C.g_object_ref(C.gpointer(coreglib.InternObject(toggle).Native()))

	C.adw_toggle_group_add(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(toggle)
}

// Active gets the index of the active toggle in self.
//
// Returns GTK_INVALID_LIST_POSITION if no toggle is active.
//
// The function returns the following values:
//
//   - guint: active toggle index.
func (self *ToggleGroup) Active() uint {
	var _arg0 *C.AdwToggleGroup // out
	var _cret C.guint           // in

	_arg0 = (*C.AdwToggleGroup)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_toggle_group_get_active(_arg0)
	runtime.KeepAlive(self)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// ActiveName gets the name of the active toggle in self.
//
// Can be NULL if the currently active toggle doesn't have a name.
//
// See toggle:name.
//
// The function returns the following values:
//
//   - utf8 (optional): active toggle name.
func (self *ToggleGroup) ActiveName() string {
	var _arg0 *C.AdwToggleGroup // out
	var _cret *C.char           // in

	_arg0 = (*C.AdwToggleGroup)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_toggle_group_get_active_name(_arg0)
	runtime.KeepAlive(self)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// CanShrink gets whether the toggles can be smaller than the natural size of
// their contents.
//
// The function returns the following values:
//
//   - ok: whether the toggles can shrink.
func (self *ToggleGroup) CanShrink() bool {
	var _arg0 *C.AdwToggleGroup // out
	var _cret C.gboolean        // in

	_arg0 = (*C.AdwToggleGroup)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_toggle_group_get_can_shrink(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Homogeneous gets whether all toggles take the same size.
//
// The function returns the following values:
//
//   - ok: whether all toggles take the same size.
func (self *ToggleGroup) Homogeneous() bool {
	var _arg0 *C.AdwToggleGroup // out
	var _cret C.gboolean        // in

	_arg0 = (*C.AdwToggleGroup)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_toggle_group_get_homogeneous(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// NToggles gets the number of toggles within self.
//
// The function returns the following values:
//
//   - guint: number of toggles.
func (self *ToggleGroup) NToggles() uint {
	var _arg0 *C.AdwToggleGroup // out
	var _cret C.guint           // in

	_arg0 = (*C.AdwToggleGroup)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_toggle_group_get_n_toggles(_arg0)
	runtime.KeepAlive(self)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Toggle gets the toggle with index from self.
//
// The function takes the following parameters:
//
//   - index toggle's index.
//
// The function returns the following values:
//
//   - toggle (optional): toggle.
func (self *ToggleGroup) Toggle(index uint) *Toggle {
	var _arg0 *C.AdwToggleGroup // out
	var _arg1 C.guint           // out
	var _cret *C.AdwToggle      // in

	_arg0 = (*C.AdwToggleGroup)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.guint(index)

	_cret = C.adw_toggle_group_get_toggle(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(index)

	var _toggle *Toggle // out

	if _cret != nil {
		_toggle = wrapToggle(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _toggle
}

// ToggleByName gets the toggle with the name name from self.
//
// The function takes the following parameters:
//
//   - name: toggle name.
//
// The function returns the following values:
//
//   - toggle (optional): toggle.
func (self *ToggleGroup) ToggleByName(name string) *Toggle {
	var _arg0 *C.AdwToggleGroup // out
	var _arg1 *C.char           // out
	var _cret *C.AdwToggle      // in

	_arg0 = (*C.AdwToggleGroup)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.adw_toggle_group_get_toggle_by_name(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(name)

	var _toggle *Toggle // out

	if _cret != nil {
		_toggle = wrapToggle(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _toggle
}

// Toggles returns a gio.ListModel that contains the toggles of the group.
//
// This can be used to keep an up-to-date view. The model also implements
// gtk.SelectionModel and can be used to track and change the active toggle.
//
// The function returns the following values:
//
//   - selectionModel: GtkSelectionModel for the group's toggles.
func (self *ToggleGroup) Toggles() *gtk.SelectionModel {
	var _arg0 *C.AdwToggleGroup    // out
	var _cret *C.GtkSelectionModel // in

	_arg0 = (*C.AdwToggleGroup)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_toggle_group_get_toggles(_arg0)
	runtime.KeepAlive(self)

	var _selectionModel *gtk.SelectionModel // out

	{
		obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
		_selectionModel = &gtk.SelectionModel{
			ListModel: gio.ListModel{
				Object: obj,
			},
		}
	}

	return _selectionModel
}

// Remove removes toggle from self.
//
// The function takes the following parameters:
//
//   - toggle to remove.
func (self *ToggleGroup) Remove(toggle *Toggle) {
	var _arg0 *C.AdwToggleGroup // out
	var _arg1 *C.AdwToggle      // out

	_arg0 = (*C.AdwToggleGroup)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.AdwToggle)(unsafe.Pointer(coreglib.InternObject(toggle).Native()))

	C.adw_toggle_group_remove(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(toggle)
}

// RemoveAll removes all toggles from self.
func (self *ToggleGroup) RemoveAll() {
	var _arg0 *C.AdwToggleGroup // out

	_arg0 = (*C.AdwToggleGroup)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	C.adw_toggle_group_remove_all(_arg0)
	runtime.KeepAlive(self)
}

// SetActive sets the active toggle for self.
//
// If the index is larger than the number of toggles in self, unsets the current
// active toggle.
//
// The function takes the following parameters:
//
//   - active: toggle index.
func (self *ToggleGroup) SetActive(active uint) {
	var _arg0 *C.AdwToggleGroup // out
	var _arg1 C.guint           // out

	_arg0 = (*C.AdwToggleGroup)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.guint(active)

	C.adw_toggle_group_set_active(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(active)
}

// SetActiveName sets the active toggle for self.
//
// The name can be set via toggle:name.
//
// If name is NULL, unset the current active toggle instead.
//
// The function takes the following parameters:
//
//   - name (optional): toggle name.
func (self *ToggleGroup) SetActiveName(name string) {
	var _arg0 *C.AdwToggleGroup // out
	var _arg1 *C.char           // out

	_arg0 = (*C.AdwToggleGroup)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if name != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.adw_toggle_group_set_active_name(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(name)
}

// SetCanShrink sets whether the toggles can be smaller than the natural size of
// their contents.
//
// If can_shrink is TRUE, the toggle labels will ellipsize.
//
// See gtk.Button:can-shrink.
//
// The function takes the following parameters:
//
//   - canShrink: whether the toggles can shrink.
func (self *ToggleGroup) SetCanShrink(canShrink bool) {
	var _arg0 *C.AdwToggleGroup // out
	var _arg1 C.gboolean        // out

	_arg0 = (*C.AdwToggleGroup)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if canShrink {
		_arg1 = C.TRUE
	}

	C.adw_toggle_group_set_can_shrink(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(canShrink)
}

// SetHomogeneous sets whether all toggles take the same size.
//
// The function takes the following parameters:
//
//   - homogeneous: whether all toggles should take the same size.
func (self *ToggleGroup) SetHomogeneous(homogeneous bool) {
	var _arg0 *C.AdwToggleGroup // out
	var _arg1 C.gboolean        // out

	_arg0 = (*C.AdwToggleGroup)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if homogeneous {
		_arg1 = C.TRUE
	}

	C.adw_toggle_group_set_homogeneous(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(homogeneous)
}
